

FAQ по библиотеке libakrypt
====================================================

Как отследить ошибки при выполнении библиотечных функций?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для отслеживания ошибок при работе с библиотечными функциями необходимо использовать функцию ``ak_error_get_value()``.

*Увидеть примеры ее использования можно во всех примерах раздела FAQ.*


БЛОЧНЫЕ ШИФРЫ
----------------

Процесс зашифрования данных блочным шифром состоит из следующих шагов:

	1. Определение параметров шифрования (теоретическая часть);
	
	2. Определение открытого текста и выделение памяти под зашифрованный текст;
	
	3. Создание контекста ключа блочного шифрования ``ak_bckey``;
	
	4. Инициализация секретного ключа блочного шифрования;
	
	5. В случае, если необходима синхропосылка или имитовставка - создание синхропосылки или выработка имитовставки;
	
	6. Зашифрование открытого текста.
	

Как создать контекст ключа блочного шифрования?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Контекст ключа ``ak_bckey`` – основная структура данных в разделе блочного шифрования.

Создать ее можно несколькими способами:

	1. Инициализация контекста ключа значением, выработанным из заданного значения пароля при помощи алгоритма PBKDF2, описанного  в рекомендациях по стандартизации Р 50.1.111-2016 (Пароль должен быть непустой строкой символов в формате utf8):

:: 

	ak_bckey_set_key_from_password(
		&key, /*Контекст ключа алгоритма блочного шифрования*/
		password, /*Пароль, представленный в виде строки символов*/
		strlen(password), /*Длина пароля в байтах*/
		s, /*Случайный вектор, представленный в виде строки символов.*/
		strlen(s) /*Длина случайного вектора в байтах*/
		);

*Использование функции можно увидеть в следующих примерах:*

*Пример 1,2,3,4 - 	ДОБАВИТЬ*

	2. Инициализация контекста ключа случайным (псевдо-случайным) значением, выработанным генератором псевдо-случайных чисел:

::

	ak_bckey_set_key_random(
		&key, /*Контекст ключа алгоритма блочного шифрования*/
		&rand /*Контекст генератора случайных (псевдослучайных) чисел*/
		);


*Использование функции можно увидеть в следующих примерах:*
*Пример 6,8,9 - 	ДОБАВИТЬ*

	3. Инициализация контекста ключа значением, содержащимся в области памяти: ОПИСАТЬ АРГУМЕНТЫ

::

	ak_bckey_set_key(&key, skey, sizeof(skey))

Как создать секретный ключ алгоритма блочного шифрования?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Создать секретный ключ можно несколькими способами:

	1. С помощью функции алгоритма Магма:
:: 

	ak_bckey_create_magma(&key);

*Использование функции можно увидеть в следующих примерах*

*Пример 2 –* 

	2. С помощью функции алгоритма Кузнечик:
:: 
	
	ak_bckey_create_kuznechik(&key);

*Использование функции можно увидеть в следующих примерах:*

*Пример  4 - ини*


	3. По OID алгоритма:
::
	
	ak_bckey_create_oid(&key, ak_oid_find_by_name("magma"));
	
	/* Возможные значения OID для aead шифрования:
    
   	"magma"
	"kuznechik"
    
        Все OID аналогичны заданию функции напрямую */  


*Примеры использования функции можно посмотреть в следующих примерах:*

*Пример 1 - 	ДОБАВИТЬ*



Как зашифровать/расшифровать данные в режиме простой замены (electronic codebook, ecb)?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Зашифровать текст в режиме простой замены (ecb) можно с помощью следующей функции: 

::

	ak_bckey_encrypt_ecb(
		&key, /*Контекст ключа алгоритма блочного шифрования*/
		data, /*Указатель на область памяти, где хранятся данные для зашифрования */
		out,  /*Указатель на область памяти, куда помещаются зашифрованные данные*/
		128   /* Размер зашифровываемых данных (в байтах)*/
		);

*Использование функции можно увидеть в следующих примерах*

*Пример 1 – инициализация секретного ключа по OID алгоритма Кузнечик*


Расшифровать в режиме простой замены (ecb) можно с помощью функции, аналогичной зашифрованию:

:: 

	ak_bckey_decrypt_ecb(
		&key, /*Контекст ключа алгоритма блочного шифрования*/
		data, /*Указатель на область памяти, где хранятся данные для зашифрования */
		out,  /*Указатель на область памяти, куда помещаются зашифрованные данные*/
		128   /* Размер зашифровываемых данных (в байтах)*/
		);

*Использование функции можно увидеть в следующих примерах:*


Как зашифровать/расшифровать данные в режиме простой замены с зацеплением из ГОСТ Р 34.13-2015 (cipher block chaining, cbc)?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Зашифровать текст в режиме простой замены (cbc) можно с помощью следующей функции: 

::

	ak_bckey_encrypt_cbc(
		&key, /* Контекст ключа алгоритма блочного шифрования */
		data, /* Указатель на область памяти, где хранятся данные для зашифрования */
		out,  /* Указатель на область памяти, куда помещаются зашифрованные данные */
		128,  /* Размер зашифровываемых данных (в байтах) */
		openssl_ivcbc, /* Указатель на произвольную область памяти - синхропосылку */
		sizeof(openssl_ivcbc) /* Длина синхропосылки в байтах. Согласно  стандарту ГОСТ Р 34.13-2015 длина
		синхропосылки должна быть ровно в два раза меньше, чем длина блока, 
		то есть 4 байта для Магмы и 8 байт для Кузнечика.*/
		);

Предварительно необходимо создать синхропосылку, передаваемую в качестве аргумента в описанную выше функцию.

Пример синхропосылки:

::

	ak_uint8 openssl_ivcbc[32] = {
		0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0, 
		0xa1, 0xb2, 0xc3, 0xd4, 0xe5, 0xf0, 0x01, 0x12, 
		0x23, 0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x90, 
		0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19
		};

Расшифровать текст в режиме простой замены (cbc) можно с помощью функции, аналогичной зашифрованию: 

::

	ak_bckey_decrypt_cbc(
		&key, /* Контекст ключа алгоритма блочного шифрования*/
		data, /* Указатель на область памяти, где хранятся данные для зашифрования */
		out, /* Указатель на область памяти, куда помещаются зашифрованные данные */
		128 /* Размер зашифровываемых данных (в байтах) */
		openssl_ivcbc, /* Указатель на произвольную область памяти - синхропосылку */
		sizeof(openssl_ivcbc) /*Длина синхропосылки в байтах. Согласно  стандарту ГОСТ Р 34.13-2015 длина 
		синхропосылки должна быть ровно в два раза меньше, чем длина блока, 
		то есть 4 байта для Магмы и 8 байт для Кузнечика */
		);

*Использование функций можно увидеть в следующих примерах:*

*Пример 12 и 13 –*

Как зашифровать/расшифровать данные в режиме гаммирования – из ГОСТ Р 34.13-2015 (counter mode, ctr)?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Как зашифровать/расшифровать данные в режиме гаммирования с обратной связью по выходу (output feedback, ofb)?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Как зашифровать/расшифровать данные в режиме гаммирования с обратной связью по шифртексту из ГОСТ Р 34.13-2015 (cipher feedback, cfb)?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Как зашифровать/расшифровать данные в режиме «CTR-ACPKM» из Р1323565.1.017—2018?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Как зашифровать/расшифровать данные в режиме «XTS»?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



АЛГОРИТМ AEAD
----------------------------------------------------
Процесс зашифрования данных аутентифицированным шифрованием состоит из следующих шагов:

	1. Определение параметров шифрования (теоретическая часть);
	
	2. Определение открытого текста и выделение памяти под зашифрованный текст;
	
	3. Создание контекста ключа аутентифицированного шифрования ``ak_aead``;
	
	4. Инициализация ключей шифрования и аутентификации аутентифицированного шифрования;
	
	5. В случае, если необходима синхропосылка или имитовставка - создание синхропосылки или выработка имитовставки;
	
	6. Зашифрование открытого текста.

Как создать контекст алгоритма аутентифицированного шифрования?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В данной библиотеке описано 12 функций для создания контекста алгоритма аутентифицированного шифрования. Коротко рассмотрим каждую из них здесь.

	1. Создание контекста алгоритма аутентифицированного шифрования Р 1323565.1.024-2019 для блочного шифра Магма
::

	ak_aead_create_mgm_magma


	2. Создание контекста алгоритма аутентифицированного шифрования Р 1323565.1.024-2019 для блочного шифра Кузнечик
::

	ak_aead_create_mgm_kuznechik
	
	3. Создание контекста алгоритма аутентифицированного шифрования xtsmac для блочного шифра Магма
::

	ak_aead_create_xtsmac_magma
	
	4. Создание контекста алгоритма аутентифицированного шифрования ctr-cmac для блочного шифра Магма
:: 

	ak_aead_create_ctr_cmac_magma
	
	5. Создание контекста алгоритма аутентифицированного шифрования ctr-cmac для блочного шифра Кузнечик
::

	ak_aead_create_ctr_cmac_kuznechik
	
	6. Создание контекста алгоритма аутентифицированного шифрования ctr-nmac для блочного шифра Магма
:: 

	ak_aead_create_ctr_nmac_magma

	7. Создание контекста алгоритма аутентифицированного шифрования ctr-nmac для блочного шифра Кузнечик
::

	ak_aead_create_ctr_nmac_kuznechik
	
	8. Создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Магма и функции хеширования Стрибог256
::

	ak_aead_create_ctr_hmac_magma_streebog256
	
	9. Создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Кузнечик и функции хеширования Стрибог256
::

	ak_aead_create_ctr_hmac_kuznechik_streebog256

	10. Создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Магма и функции хеширования Стрибог512
::
	
	ak_aead_create_ctr_hmac_magma_streebog512
	
	11. Создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Кузнечик и функции хеширования Стрибог512
::

	ak_aead_create_ctr_hmac_kuznechik_streebog512
	
	12. Создание контекста алгоритма аутентифицированного шифрования по заданному oid
::

	ak_aead_create_oid


Как зашифровать/расшифровать данные с помощью аутентифицируемого шифрования с одновременным вычислением/проверки имитовставки?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Зашифровать текст аутентифицируемым шифрованием можно с помощью следующей функции
::

	ak_aead_encrypt(
    			&a, /* контекст алгоритма аутентифицированного шифрования */
    			packet,      /* указатель на ассоциированные (незашифровываемые) данные */
    			41,          /* длина ассоциированных данных в октетах */
    			packet + 41, /* указатель на зашифровываемые данные */
    			packet + 41, /* указатель на зашифрованные данные */
    			67,          /* размер зашифровываемых данных в октетах */
    			iv,          /* указатель на синхропосылку */
    			a.iv_size,   /* длина синхропосылки в октетах */
    			tag,         /* указатель на область памяти, куда будет помещено значение имитовставки */
    			a.tag_size   /* ожидаемый размер имитовставки в байтах */
    			))
			
Расшифровать текст аутентифицируемым шифрованием можно с помощью функции, аналогичной зашифрованию:
:: 

	ak_aead_encrypt(
    			&a, /* контекст алгоритма аутентифицированного шифрования */
    			packet,      /* указатель на ассоциированные (незашифровываемые) данные */
    			41,          /* длина ассоциированных данных в октетах */
    			packet + 41, /* указатель на расшифровываемые данные */
    			packet + 41, /* указатель на расшифрованные данные */
    			67,          /* размер зашифровываемых данных в октетах */
    			iv,          /* указатель на синхропосылку */
    			a.iv_size,   /* длина синхропосылки в октетах */
    			tag,         /* указатель на область памяти, где расположена проверяемая имитовставки */
    			a.tag_size   /* ожидаемый размер имитовставки в байтах */
    			))

*Использование функций можно увидеть в следующих примерах:*

*Пример 12 и 13 –*


ЭЛЕКТРОННАЯ ПОДПИСЬ
----------------------------------------------------


Как ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


ДРУГИЕ БИБЛИОТЕЧНЫЕ ФУНКЦИИ
----------------------------------------------------

Как выработать случайное (псевдо-случайное значение)?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Несколько вариантов:

1)	Линейный конгруэнтный генератор (Linear congruential generator, lcg):
::

	ak_random_create_lcg(&rand);

Примеры:

2)	Нелинейный конгруэнтный генератор с обратной квадратичной связью (Nonlinear-feedback shift register, nlfsr)
::
	
	ak_random_create_nlfsr(&rand);
	
3) 	Генератор по заданному OID алгоритма генерации псевдо-случайных чисе
:: 

	ak_random_create_oid(&rand, ak_oid_find_by_name( /* Нужный алгоритм */ ));

*Использование функций можно увидеть в следующих примерах:*

*Пример 12 и 13 –*


---Как сравнить две области памяти одинакового размера?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Произвести сравнение двух областей памяти одинакового размера можно с помощью встроенной функции библиотеки ``ak_ptr_is_equal``.

*Пример использования можно найти в файле ak_tools.c на строке 633*

!!!ссылка на пример!!!
	

-Как открыть файл на чтение?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Файл на чтение можно открыть с помощью функции ``ak_file_open_to_read``.

Чтобы прочитать из файла необходимо использовать функцию ``ak_file_read``.

*Проверить работу данных функций можно в примере 23.*


-Как прочитать пароль из консоли?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Чтение пароля из консоли реализовано в библиотеке с помощью фукнции  ``ak_password_read``. 

*Проверить работу данной функции можно в примере 28.*


-Как прочитать строку из консоли?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Чтение строки из консоли реализовано в библиотеке с помощью фукнции  ``ak_string_read``. 

*Проверить работу данной функции можно в примере 29.*


-Как установить уровень аудита в коде?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Выставить уровень аудита можно с помощью функции ``ak_log_set_level``. В качестве аргумента в данную фунцию передается один из трех уровней:

	* Первый уровень аудита - ``ak_log_none`` - выводятся олько сообщения об ошибках;
	* Второй уровень аудита - ``ak_log_standard`` - выводятся все сообщения из первого уровня, а также сообщения, регламентируемые существующей
    нормативной базой;
	* Третий (максимальный) уровень - ``ak_log_maximum`` - выводятся все сообщения, доступные на первых двух уровнях, а также
    сообщения отладочного характера, позволяющие проследить логику работы функций библиотеки.
   
*Пример использования данной функции*



ОПИСАНИЕ ПРИМЕРОВ
------------------------------
example-1  	
	* создание секретного ключа алгоритма Кузнечик по OID; 
	* инициализация контекста ключа значением, выработанным из заданного значения пароля; 
	* зашифрование и расшифрование текста в режиме простой замены (ecb);

example-2 
	* создание секретного ключа алгоритма Магма по OID;
	* инициализация контекста ключа значением, выработанным из заданного значения пароля; 
	* зашифрование и расшифрование текста в режиме ctr;

example-3
	* создание секретного ключа алгоритма Кузнечик; 
	* инициализация контекста ключа случайным (псевдо-случайным) значением, выработанным генератором псевдо-случайных чисел (lcg); 
	* зашифрование и расшифрование текста в режиме ofb; 

example-4 
	* создание секретного ключа алгоритма Магма; 
	* инициализация контекста ключа случайным (псевдо-случайным) значением, выработанным генератором псевдо-случайных чисел (nlfsr); 
	* зашифрование и расшифрование текста в режиме cfb;

example-5 почти ок 
	* создание секретного ключа алгоритма Магма; 
	* инициализация контекста ключа значением, содержащимся в области памяти; 
	* зашифрование и расшифрование текста в режиме acpkm; 
	* **!!!! НАПИСАТЬ КОММЕНТЫ**

example-6 почти ок 
	* создание секретного ключа алгоритма Магма; 
	* инициализация контекста ключа значением, содержащимся в области памяти; 
	* зашифрование и расшифрование текста в режиме xtsmac; 
	* **!!!! НАПИСАТЬ КОММЕНТЫ**

example-7 почти ок 
	* создание секретного ключа алгоритма Кузнечик; 
	* инициализация контекста ключа случайным (псевдо-случайным) значением, выработанным генератором псевдо-случайных чисел (nlfsr); 
	* зашифрование и расшифрование текста в режиме cbc; 
	* **!!!! НАПИСАТЬ КОММЕНТЫ**

example-8
	* создание контекста алгоритма аутентифицированного шифрования Р 1323565.1.024-2019 для блочного шифра Магма; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации по отдельности; 
	* зашифрование данных с одновременным вычислением имитовставки; 

example-9
	* создание контекста алгоритма аутентифицированного шифрования Р 1323565.1.024-2019 для блочного шифра Кузнечик; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки;

example-10
	* создание контекста алгоритма аутентифицированного шифрования xtsmac для блочного шифра Магма; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки;

example-11
	* создание контекста алгоритма аутентифицированного шифрования ctr-cmac для блочного шифра Магма; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки;

example-12
	* создание контекста алгоритма аутентифицированного шифрования ctr-cmac для блочного шифра Кузнечик; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации;
	* зашифрование данных с одновременным вычислением имитовставки; 

example-13 
	* создание контекста алгоритма аутентифицированного шифрования ctr-nmac для блочного шифра Магма; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки; 

example-14
	* создание контекста алгоритма аутентифицированного шифрования ctr-nmac для блочного шифра Кузнечик; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки;  

example-15
	* создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Магма и функции хеширования Стрибог256; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки; 

example-16 
	* создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Кузнечик и функции хеширования Стрибог256; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки; 

example-17
	* создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Магма и функции хеширования Стрибог512; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки; 

example-18 
	* создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Кузнечик и функции хеширования Стрибог512;
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки; 

example-19
	* создание контекста алгоритма аутентифицированного шифрования по заданному OID; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки;

example-20 
	* использование электронной подписи на основе вычисленного хеш-кода подписываемого сообщения;
	* выставление уровня аудита;
	* инициализация контекста секретного ключа алгоритма электронной подписи случайным (псевдо-случайным) значением, выработанным генератором псевдо-случайных чисел (lcg);
	
example-21
	* использование электронной подписи для константного значения строки;
	* выставление уровня аудита;
	* инициализация контекста секретного ключа алгоритма электронной подписи константным значением;
	* проверка электронной подписи строки;

example-22 
	* использование электронной подписи для исполняемого файла;
	* выставление уровня аудита;
	* инициализация контекста секретного ключа алгоритма электронной подписи константным значением;
	* проверка электронной подписи файла;
	
example-23 
	* открытие файла на чтение;
	* чтение электронной подписи из файла;
	
example-24
	* инициализация контекста алгоритма бесключевого хеширования, регламентируемого стандартом ГОСТ Р 34.11-2012, с длиной хешкода, равной 256 бит (функция Стрибог256);
	* хэширование константной строки; 

example-25
	* инициализация контекста алгоритма бесключевого хеширования, регламентируемого стандартом ГОСТ Р 34.11-2012, с длиной хешкода, равной 512 бит (функция Стрибог512);
	* хэширование константной строки; 
	
example-26 НЕ ОК
	* хэширование файла; 
	* **!!! НАПИСАТЬ ПРИМЕР**
	
example-27
	* преобразование строки символов, содержащую последовательность шестнадцатеричных цифр, в массив данных;
	
example-28 
	* чтение пароля из консоли; 

example-29 
	* чтение строки символов из консоли; 

example-30 почти ок
	* чтение строки символов из консоли; 
	* **!!!маша должна написать комментарии к строкам!**
	
example-31 почти ок
	* чтение строки символов из консоли; 
	* **!!!маша должна написать комментарии к строкам!**

example-32 почти ок
	* реализация алгоритма base64; 
	* **!!!спросить у маши добавлен ли в этом коде какой то функционал библиотеке или нет!**


